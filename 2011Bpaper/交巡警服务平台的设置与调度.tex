\documentclass{ctexart}

\usepackage{appendix}
\usepackage{listings}% 插入代码
\usepackage{xcolor} 
\usepackage{graphicx}% 插入表格/图片
\usepackage{booktabs} % 绘制表格
\usepackage{longtable} %自动分页
\usepackage{caption} % 标题
\usepackage{geometry}
\usepackage{array}
\usepackage{amsmath}
\usepackage{amsfonts} % 神奇数学符号库
\usepackage{subfigure} % 插入图片
\usepackage{longtable}
\usepackage{abstract}% 摘要
\pagestyle{plain} % 页眉消失
\usepackage{setspace}
\usepackage{multirow}% 表格
\usepackage{diagbox}
\usepackage{enumerate}% 序号
\usepackage{float}% 固定图片或表格的位置
\usepackage{gensymb}
\usepackage{microtype}
\usepackage{tikz}% 绘制流程图
\usetikzlibrary{shapes.geometric, arrows}
\usepackage{hyperref}% 导航窗格

\geometry{a4paper,left=2.5cm,right=2.5cm,top=2cm,bottom=2cm}% 页边距
\lstset{
    numbers=left, % 设置行号位置
    numberstyle=\tiny, % 设置行号大小
    keywordstyle=\color{blue}, % 设置关键字颜色
    commentstyle=\color[cmyk]{1,0,1,0}, % 设置注释颜色
    escapeinside=``, % 逃逸字符(1左面的键)，用于显示中文
    breaklines, % 自动折行
    extendedchars=false, % 解决代码跨页时，章节标题，页眉等汉字不显示的问题
    xleftmargin=1em,xrightmargin=1em, aboveskip=1em, % 设置边距
    tabsize=4, % 设置tab空格数
    showspaces=false % 不显示空格
}

\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=red!30]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=orange!30]
\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\title{交巡警服务平台的设置与调度}
\date{}
\author{}

\begin{document}
\maketitle
\renewcommand{\abstractname}{\Large\textbf{摘要}\\} % 使用 \huge 调整字体大小
\vspace{-4em} % 调整标题上间距
\begin{abstract}
\normalsize
本文针对交巡警服务平台的设置与调度这一问题，建立了回溯算法，扩散算法，最大流二分查找，工作量函数等多种模型，优化了交巡警服务平台的管辖范围设定与调度问题，并成功抓捕嫌疑人。

针对问题一，首先读取文件并进行数据预处理，为解决划分辖区这一问题，需满足交巡警平台管辖的范围内出现突发事件时尽量能在3分钟内抵达事发地这一条件，可将交巡警平台在三分钟内抵达该路口节点作为约束条件。基于{\bfseries dijkstra算法}，以交巡警平台作为起始点向外延伸三公里进行搜索，但无法直接解决重复问题，引入{\bfseries 扩散搜索模型}后划分管辖区域。

针对问题二，    为解决这一指派问题，需对进出该区的13条交通要道实现快速全封锁，通过调度全区警力资源以最快速度完成封锁。为此，我们需建立最优调度方案使这一目标最快实现。
为实现对进出该区的13条交通要道快速全封锁，即指派交巡警服务平台到交通要道，目标为封锁完成的时间最短。据此建立{\bfseries 最大流二分查找模型}，规划出最佳封锁方案，所需时间为8.015分钟，平均用时为5.292min。

针对问题三，基于问题一已建立的{\bfseries 扩散搜索模型}，引入{\bfseries 工作量判定函数}，综合考虑A区每个交巡警平台范围内的路径长度与节点发案率，将平台工作量均衡并且尽量保证出警时间在三分钟内作为优化目标，
利用蒙特卡罗方法，随机生成平台增设数量，考虑增加不同平台数目与部署位置的影响，最终确定增加平台为（A21，87），
（A22，61），
（A23，28），
（A24，38），以达到最优设置方案。

针对问题四，为解决原有问题但不改变平台数量，分别以该市所有路口节点为中心，计算该节点三公里内的总工作量，得到由各节点总工作量，通过计算密度函数验证其基本服从{\bfseries 卡方分布}。基于减小方差的目的每次选取平台位置都选择最靠近平均数的节点，以保证在该次选取的数据集中方差最小。选取平台后，从扣除平台所在点及其三公里所有可选点，以避免平台管辖区域的冗余。之后在重新计算剩余各点工作量的平均数，直到选出八十个平台为止，原变异系数:0.46，现变异系数:0.41，证明了工作量更为平均。

针对问题五，基于问题二，先将嫌疑人逃跑速率设为可变参数，调整递归回溯的最远距离，再用{\bfseries 扩散搜索模型}得出嫌疑人的可能的逃跑区域。以最小包围时间为优化目标，建立{\bfseries 最大流模型}并用二分查找进行求解，以同一时间间隔进行迭代，最终得出优化的围堵方案。当嫌疑人逃跑速度为60km/h时，最优围堵时间是10.8分钟。

本论文创新性的引入{\bfseries 扩散搜索模型}与{\bfseries 工作量判定函数}，并首次在此类指派问题中应用{\bfseries 最大流二分查找模型}，取得了较为精确的优化结果。

{\bfseries 关键字}：扩散搜索模型，DFS，最大流二分搜索，工作量函数
\end{abstract}
\newpage



% 重新设置页面边距
    \newgeometry{a4paper,left=3.18cm,right=3.18cm,top=2.54cm,bottom=2.54cm}
	\section{问题背景与重述}
	\subsection{问题背景}
    “有困难找警察”，是家喻户晓的一句流行语。警察肩负着刑事执法、治安管理、交通管理、服务群众四大职能。为了更有效地贯彻实施这些职能，需要在市区的一些交通要道和重要部位设置交巡警服务平台。每个交巡警服务平台的职能和警力配备基本相同。由于警务资源是有限的，如何根据城市的实际情况与需求合理地设置交巡警服务平台、分配各平台的管辖范围、调度警务资源是警务部门面临的一个实际课题。
试就某市设置交巡警服务平台的相关情况，建立数学模型分析研究下面的问题：
    \subsection{问题表述}
    \begin{enumerate}[(1)]
        \item 问题一：附件1中的附图1给出了该市中心城区A的交通网络和现有的20个交巡警服务平台的设置情况示意图，相关的数据信息见附件2。请为各交巡警服务平台分配管辖范围，使其在所管辖的范围内出现突发事件时，尽量能在3分钟内有交巡警（警车的时速为60km/h）到达事发地。
        \item 问题二：对于重大突发事件，需要调度全区20个交巡警服务平台的警力资源，对进出该区的13条交通要道实现快速全封锁。实际中一个平台的警力最多封锁一个路口，请给出该区交巡警服务平台警力合理的调度方案。
        \item 问题三：根据现有交巡警服务平台的工作量不均衡和有些地方出警时间过长的实际情况，拟在该区内再增加2至5个平台，请确定需要增加平台的具体个数和位置。
        \item 问题四：针对全市（主城六区A，B，C，D，E，F）的具体情况，按照设置交巡警服务平台的原则和任务，分析研究该市现有交巡警服务平台设置方案（参见附件）的合理性。如果有明显不合理，请给出解决方案。
        \item 问题五：如果该市地点P（第32个节点）处发生了重大刑事案件，在案发3分钟后接到报警，犯罪嫌疑人已驾车逃跑。为了快速搜捕嫌疑犯，请给出调度全市交巡警服务平台警力资源的最佳围堵方案。

    \end{enumerate}

    \section{问题分析}
    \subsection{问题一分析}
    对于问题一，为解决划分辖区这一问题，需满足交巡警平台管辖的范围内出现突发事件时，尽量能在3分钟内抵达事发地这一条件，可从三分钟内抵达入手，将其作为约束条件，进行搜索，由此根据附图1中的交通网络，现有的二十个交巡警服务平台的设置情况示意图和附件2中的相关数据信息，划分管辖区域。

    \subsection{问题二分析}
    首先，这个是一个指派问题，为解决需对进出该区的13条交通要道实现快速全封锁这一问题，需要通过调度全区警力资源以最快速度完成封锁。为此，我们需建立最优调度方案使这一目标最快实现。
    \subsection{问题三分析}
	基于问题一已建立的扩散搜索模型，引入工作量判定函数，综合考虑A区每个交巡警平台范围内的路径长度与节点发案率，为使平台工作量均衡并且尽量保证出警时间在三分钟内，最终确定增加平台的位置与数目，以达到最优设置方案。
    \subsection{问题四分析}

根据对原平台部署方案的分析，其部署方案存在同一区域交巡警平台重复部署，偏远地区未部署交巡警平台等问题。分别以该市所有路口节点为中心，计算该节点三公里内的总工作量，得到由各节点总工作量组成的列表，由大到小排序后，通过计算密度函数验证其基本服从卡方分布。基于减小方差的目的每次选取平台位置都选择最靠近平均数的节点，以保证在该次选取的数据集中方差最小。选取平台后，从可选点中扣除平台所在点及其三公里所有可选点，以避免平台管辖区域的冗余。之后在重新计算剩余各点工作量的平均数，重复以上步骤，直到选出八十个平台为止。

    \subsection{问题五分析}
    对于该问题，看作与问题二类似的指派问题，在利用第一问的扩散算法，得出最小包围圈上的点后，转化为对这些点实现快速全封锁的问题，需要通过调度全区警力资源以最快速度完成封锁。为此，我们需建立最优调度方案使这一目标最快实现。
    \section{模型假设}
    \begin{enumerate}[(1)]
        \item 交巡警服务平台管辖范围不能重叠。
        \item 不考虑交通拥堵，假设各节点间路段通畅。
        \item 假设问题二中总平台数不可变。
        \item 问题四中当嫌疑人抵达出城节点，则视为围堵失败。
    \end{enumerate}

    \section{符号说明}
\begin{center}
    \setlength{\tabcolsep}{9mm}{
        \begin{tabular}{ccc}
            \specialrule{1.2pt}{0pt}{0pt} % 设置顶部粗线
            \textbf{符号} & \textbf{意义} & \textbf{单位}\\
            \midrule  % 设置中间横线
            \textnormal{\(G\)} & \textnormal{图} & \textnormal{}\\
            \textnormal{\(V\)} & \textnormal{节点集合} & \textnormal{}\\
            \textnormal{\(E\)} & \textnormal{边集合} & \textnormal{}\\
            \textnormal{\(w\)} & \textnormal{权重函数} & \textnormal{}\\
            \textnormal{\(s \)} & \textnormal{起始节点} & \textnormal{}\\
            \textnormal{\(u\)} & \textnormal{未访问节点} & \textnormal{}\\
            \textnormal{\(v\)} & \textnormal{邻接节点} & \textnormal{}\\
            \textnormal{\(P\)} & \textnormal{交巡警服务平台} & \textnormal{}\\
            \textnormal{\( t \)} & \textnormal{时间} & \textnormal{分钟}\\
            \specialrule{1.2pt}{0pt}{0pt} % 设置底部粗线
        \end{tabular}
    }
\end{center}

    \section{模型建立与求解}
    \subsection{问题一模型的建立与求解}
    \subsubsection{问题一模型的建立}
首先，读取文件并进行数据预处理，为解决划分辖区这一问题，需满足交巡警平台管辖的范围内出现突发事件时尽量能在3分钟内抵达事发地这一条件，可将交巡警平台在三分钟内抵达该路口节点作为约束条件。以交巡警平台作为起始点向外延伸三公里进行搜索，由此根据附图1中的交通网络所给出的二十个现有的交巡警服务平台的设置情况示意图和附件2中的相关数据信息，划分管辖区域。
    
    \subsubsection{数据预处理}
	首先读取文件，根据区域名称将节点坐标，节点间连接关系，平台所在节点和路口所在节点从附件二中提取出，并格式化和建立数据库，进而计算连接节点间的欧几里得距离，考虑到点对间存在一定关系，即点与点之间存在连接，并包含点之间的距离信息，构建节点网络地图。
	\subsubsection{Dijkstra算法的原理}
设有一个图 \(G = (V, E)\)，其中 \(V\) 是节点集合，\(E\) 是边集合，权重函数 \(w: E \rightarrow \mathbb{R}^+\) 定义每条边的非负权重。起始节点为 \(s \)，目标是找到从 \(s \) 到所有其他节点的最短路径。

1. 初始化：
\[
\forall v \in V, \text{dist}[v] = \infty
\]
\[
\text{dist}[s] = 0
\]

2. 每次选择距离最小的未访问节点 \(u\)：
\[
u = \arg\min_{v \in Q} \text{dist}[v]
\]

3. 更新邻接节点的距离：
对于每个邻接节点 \(v\)：
\[
\text{alt} = \text{dist}[u] + w(u, v)
\]
如果 \(\text{alt} < \text{dist}[v]\)，则：
\[
\text{dist}[v] = \text{alt}
\]
并更新前驱节点：
\[
\text{prev}[v] = u
\]

4. 重复上述过程，直到所有节点都被访问过。

Dijkstra算法通过上述步骤有效地找到从源点到所有其他节点的最短路径，其时间复杂度在使用二叉堆实现优先队列时为 \(O((|E| + |V|) \log |V|)\)。

	\subsubsection{指定深度的DFS模型的建立}
为了得出平台3km距离内所有的路口，引入深度优先搜索模型：

给定一个图 \( G = (V, E) \)，其中 \( V \) 是顶点集合，\( E \) 是边集合。DFS 算法的步骤如下：

1. 初始化：标记所有节点为未访问状态。

2. 选择起始节点：从起始节点 \( v \in V \) 开始搜索。

3. 递归搜索：
   \[
   \text{DFS}(v) = 
   \begin{cases} 
   \text{visited}(v) = \text{true}, & \text{if } v \text{ is the starting node} \\
   \text{DFS}(u), & \text{for each neighbor } u \text{ of } v \text{ and } \text{visited}(u) = \text{false}
   \end{cases}
   \]

4.利用递归，搜索出3km路程内的点集，并将其标示在图上。

    \begin{figure}[H] % [H] 表示强制当前位置插入图片
        \centering % 使图片居中
        \includegraphics[width=0.6\textwidth]{"./picture/Q1_origin.png"} % 图片文件名及宽度调整
        \caption{A区未去重结果图} % 图片标题
        \label{fig:example} % 图片标签
    \end{figure}
	\subsubsection{去除重叠区域与优化}
	由于深度优先搜索算法有可能使某些路口无人管辖或邻近交巡警服务平台的管辖区域存在重叠，而在现实中，不同警局的执法范围一般不会重叠，为避免此现象发生，需要对该模型进行优化。

    %\begin{figure}[H] % [H] 表示强制当前位置插入图片
        %\centering % 使图片居中
        %\includegraphics[width=0.8\textwidth]{"./picture/map_with_number_A.png"} % 图片文件名及宽度调整
        %\caption{A区示意图} % 图片标题
        %\label{fig:example} % 图片标签
    %\end{figure}

但是深度优先搜索算法会搜索某一深度内的所有节点，进而导致同一路口节点被不同交巡警平台多次覆盖。




    %\begin{figure}[H] % [H] 表示强制当前位置插入图片
        %\centering % 使图片居中
        %\includegraphics[width=0.8\textwidth]{"F:/Git/2012_B/papers/paper picture/wset_wall_C1_9C2_0C6_68.png"} % 图片文件名及宽度调整
        %\caption{3km分配图} % 图片标题
        %\label{fig:example} % 图片标签
    %\end{figure}

为解决这一问题，从各平台同时进行向外扩散搜索，当一个节点被某一平台纳入管辖范围，就不能被其他平台搜索到，为此引入扩散搜索模型。
	\subsubsection{扩散模型的引入}
	定位每一个交巡警服务平台，对所有平台，以相同扩散速率进行搜索，若搜索到的节点未被其他平台添加到管辖区域内，则将其加入自己的管辖区。在每一轮增加搜索距离之前，计算各个平台工作量之和，根据计算结果，调整该交巡警平台的扩散搜索速率。重复此循环，直到3km内所有路口节点被搜索完毕，程序终止。

%\begin{center}
%\begin{tikzpicture}[node distance=2cm]

%\node (start) [startstop] {开始};
%\node (locate) [process, below of=start] {定位每个交巡警服务平台};
%\node (search) [process, below of=locate] {以相同扩散速率搜索};
%\node (find) [decision, below of=search, yshift=-1cm] {搜索到路口节点?};
%\node (compute) [process, below of=find, yshift=-1cm] {计算工作量函数并调整搜索速率};
%\node (repeat) [process, below of=compute] {继续循环搜索};
%\node (within) [decision, below of=repeat, yshift=-1cm] {节点被搜索完毕?};
%\node (stop) [startstop, below of=within, yshift=-1cm] {程序终止};

%\draw [arrow] (start) -- (locate);
%\draw [arrow] (locate) -- (search);
%\draw [arrow] (search) -- (find);
%\draw [arrow] (find) -- node[anchor=east] {是} (compute);
%\draw [arrow] (find.east) -- ++(1.5,0) |- node[anchor=south] {否} (repeat);
%\draw [arrow] (compute) -- (repeat);
%\draw [arrow] (repeat) -- (within);
%\draw [arrow] (within) -- node[anchor=east] {是} (stop);
%\draw [arrow] (within.east) -- ++(1.5,0) |- node[anchor=south] {否} (repeat);

%\end{tikzpicture}
%end{center}

    \begin{figure}[H] % [H] 表示强制当前位置插入图片
        \centering % 使图片居中
        \includegraphics[width=0.6\textwidth]{"./picture/liu.jpg"} % 图片文件名及宽度调整
        \caption{问题一流程图} % 图片标题
        \label{fig:example} % 图片标签
    \end{figure}

\begin{enumerate}
    \item \textbf{定位每一个交巡警服务平台}：
    
    设交巡警服务平台集合为 \( P = \{ p_1, p_2, \ldots, p_m \} \)，
    路口节点集合为 \( N = \{ n_1, n_2, \ldots, n_n \} \)。
    
    \item \textbf{以相同速率进行扩散搜索，直到搜索到路口节点}：
    
    对每一个交巡警服务平台 \( p_i \in P \)，设初始搜索速率为 \( v_0 \)，
    在时间 \( t \) 内的搜索半径为 \( r_i(t) = v_0 \cdot t \)。
    搜索半径 \( r_i \) 满足：
    \[
    r_i(t) = \min \{ r \mid \exists n_j \in N, \text{dist}(p_i, n_j) \leq r \}
    \]
    
    \item \textbf{继续重复此循环，直到3km内所有路口节点被搜索完毕，程序终止}：
    
    设搜索终止距离为 \( R = 3 \) km，
    程序在满足以下条件时终止：
    \[
    \forall n_j \in N, \text{dist}(p_i, n_j) \leq R \text{ for some } p_i \in P
    \]
\end{enumerate}

优点在于无需去除重叠区域且到案时间更短。

    \begin{figure}[H] % [H] 表示强制当前位置插入图片
        \centering % 使图片居中
        \includegraphics[width=0.6\textwidth]{"./picture/Q1 answer.png"} % 图片文件名及宽度调整
        \caption{A区扩散算法结果图} % 图片标题
        \label{fig:example} % 图片标签
    \end{figure}

	\subsubsection{结果的检验}
	虽然任意平台无法在3分钟内抵达28，29，38，39，61，92这六个节点，但可通过延长搜索时间覆盖所有节点。
\begin{center}
\begin{tabular}{ccccccc}
\toprule
路口节点&28 & 29 & 38 & 39 & 61 & 92\\
\midrule
警局节点&A15 & A15 & A16 & A2 & A7 & A20\\
\midrule
抵达时间&4.8 & 5.7 & 3.4 & 3.7 & 4.2 & 3.6\\

\bottomrule
\end{tabular}
\end{center}
	\subsubsection{问题的结论}
以下为交巡警平台的管辖范围。

\begin{center}
\begin{tabular}{ccccccc}
\toprule
交巡警平台 & 管辖节点\\
\midrule
A1 & 1、67、68、69、71、72、73、74、75、76、78\\
A2 & 2、39、40、43、44、70\\
A3 & 3、54、55、65、66\\
A4 & 4、57、60、62、63、64\\
A5 & 5、49、50、51、52、53、56、58、59\\
A6 & 6\\
A7 & 7、30、32、47、48、61\\
A8 & 8、33、46\\
A9 & 9、31、34、35、45\\
A10 & 10\\
A11 & 11、26、27\\
A12 & 12、25\\
A13 & 13、21、22、23、24\\
A14 & 14\\
A15 & 15、28、29\\
A16 & 16、36、37、38\\
A17 & 17、41、42\\
A18 & 18、80、81、82、83\\
A19 & 19、77、79\\
A20 & 20、84、85、86、87、88、89、90、91、92\\

\bottomrule
\end{tabular}
\end{center}
    \subsection{问题二模型的建立与求解}

\subsubsection{问题二的模型建立}
	为解决这一指派问题，需对进出该区的13条交通要道实现快速全封锁，通过调度全区警力资源以最快速度完成封锁。为此，我们需建立最优调度方案使这一目标最快实现。

为实现对进出该区的13条交通要道快速全封锁，即指派交巡警服务平台到交通要道，目标为封锁完成的时间最短。据此建立最大流二分查找模型，规划出最佳封锁方案。
\subsubsection{最大流算法的模型建立}
%通过对于A区路口与交巡警平台布局的观察，可以发现，大部分出入城区的路口节点在西部地区，而大部分交巡警平台却在东部地区，为此采用分布优化的策略，先满足东部封锁入城区的路口节点的需求，再，考虑西部地区的问题。
%\begin{enumerate}
%\item 分区策略：
%\item 解决东区分配需求：
%\item 西部二次分区：
%\item 解决西区分配需求：
%\end{enumerate}

	%为了减小计算量，首先对A区进行分区，通过计算A区交巡警平台与出入口节点中心，可知交巡警平台中心位置：横坐标为 334.0，纵坐标为 343.67。出入口节点中心位置：横坐标为 281.15，纵坐标为 322.08。我们可基于此

最大流问题是在给定一个源点（source）和汇点（sink）的流网络中，找到从源点到汇点的最大流量。网络中每条边都有一个容量限制，表示该边能通过的最大流量。最大流算法的目标是找到一种流量分配方式，使得从源点到汇点的总流量最大。

1.流量守恒约束

在网络的每个节点 \(v\)（除了源点和汇点）处，流量守恒原则要求：
\[
\sum_{u \in V} f(u, v) = \sum_{w \in V} f(v, w)
\]

其中，\(f(u, v)\) 表示从节点 \(u\) 到节点 \(v\) 的流量，\(V\) 表示节点集合。

2.边容量约束

每条边的流量不能超过其容量限制：
\[
0 \leq f(u, v) \leq c(u, v)
\]

其中，\(c(u, v)\) 表示边 \( (u, v) \) 的容量。

3.最大流量

最大流问题的目标是最大化从源点 \( s \) 到汇点 \( t \) 的总流量 \( |f| \)：
\[
\max |f| = \sum_{v \in V} f(s, v)
\]


\subsubsection{模型的求解}
1.二分查找法

二分查找法是一种在有序数组中查找目标值的高效算法。其基本思想是通过逐步缩小查找范围，将问题规模减半，直到找到目标值或确定目标值不存在。

2.二分查找算法步骤

（1） 初始化左右边界 \( T_{\min} \) 和 \( T_{\max} \)。

（2） 计算中点 \( T_{\text{mid}} \)：
\[
T_{\text{mid}} = \frac{T_{\min} + T_{\max}}{2}
\]

（3） 判断 \( T_{\text{mid}} \) 是否满足条件。如果满足，则更新右边界：
\[
T_{\max} = T_{\text{mid}}
\]

否则，更新左边界：

\[
T_{\min} = T_{\text{mid}}
\]

（4） 重复步骤2和3，直到左右边界足够接近。

3.最大流二分查找法结合

我们通过二分查找法找到一个最小的时间 \( T \)，使得在此时间内警察能够封锁所有关键交通要道。对于每个给定的 \( T \)，通过最大流算法判断是否能满足封锁要求。

4.具体数学模型

目标函数：
\[
\min T
\]

约束条件：
\[
\begin{aligned}
\text{s.t.} \quad & \left\{
\begin{aligned}
& \sum_{i \in P} x_{ij} \geq 1, && \forall j \in K \\
& \sum_{j \in K} x_{ij} \leq 1, && \forall i \in P \\
& x_{ij} \cdot d_{ij} \leq T, && \forall i \in P, \forall j \in K \\
& \text{flow}(T) \geq |K|
\end{aligned}
\right.
\end{aligned}
\]

其中，\( P \) 为警察局集合，\( K \) 为关键交通要道集合，\( d_{ij} \) 为警察局 \( i \) 到路口 \( j \) 的时间，\( x_{ij} \) 为二元决策变量，表示是否由警察局 \( i \) 封锁路口 \( j \)。

\subsubsection{模型求解的结果}

匹配对: [(2, 16), (4, 48), (7, 29), (8, 30), (10, 12), (11, 24), (12, 22), (13, 23), (14, 21), (15, 28), (16, 14), (19, 38), (20, 62)]

\begin{center}
\begin{tabular}{ccccccc}
\specialrule{1.2pt}{0pt}{0pt} % 设置顶部粗线
A2 & A4 & A7 & A8 & A10 & A11 & A12 \\
16 & 48 & C & D & E & F & G \\
\midrule
A13 & A14 & A15 & A16 & A19 & A20\\
1 & 2 & 3 & 4 & 5 & 6\\
\specialrule{1.2pt}{0pt}{0pt} % 设置底部粗线
\end{tabular}
\end{center}

\subsubsection{模型检验与分析}
通过最大流二分查找模型计算得到：

\begin{center}
    \setlength{\tabcolsep}{6mm}{
        \begin{tabular}{ccc}
            \specialrule{1.2pt}{0pt}{0pt} % 设置顶部粗线
            \textbf{平台} & \textbf{出入口} & \textbf{时间 (min)} \\
            \midrule  % 设置中间横线
            3 & 16 & 6.026 \\
            7 & 29 & 8.015 \\
            8 & 30 & 3.061 \\
            9 & 48 & 4.199 \\
            10 & 12 & 7.587 \\
            11 & 23 & 4.675 \\
            12 & 22 & 6.883 \\
            13 & 24 & 2.385 \\
            14 & 21 & 3.265 \\
            15 & 28 & 4.752 \\
            16 & 14 & 6.742 \\
            17 & 38 & 4.756 \\
            20 & 62 & 6.449 \\
            \specialrule{1.2pt}{0pt}{0pt} % 设置底部粗线
        \end{tabular}
    }
\end{center}

由此可知，时间都在8.015min内，平均用时为5.292min，完成了进出该区的13条交通要道实现快速全封锁。
\subsubsection{问题的结论}
解决这一指派问题，需对进出该区的13条交通要道实现快速全封锁，通过调度全区警力资源以最快速度完成封锁。为此，我们需建立最优调度方案使这一目标最快实现。

为实现对进出该区的13条交通要道快速全封锁，即指派交巡警服务平台到交通要道，目标为封锁完成的时间最短。据此建立最大流二分查找模型，规划出最佳封锁方案。
%\subsubsection{模型检验与分析}
    \subsection{问题三模型的建立与求解}
\subsubsection{模型建立}
基于问题一已建立的扩散搜索模型，引入工作量判定函数，综合考虑A区每个交巡警平台范围内的路径长度与节点发案率，将平台工作量均衡并且尽量保证出警时间在三分钟内作为优化目标，最终确定增加平台的位置与数目，以达到最优设置方案。

    \begin{figure}[H] % [H] 表示强制当前位置插入图片
        \centering % 使图片居中
        \includegraphics[width=0.6\textwidth]{"./picture/Q3 origin.png"} % 图片文件名及宽度调整
        \caption{结果图} % 图片标题
        \label{fig:example} % 图片标签
    \end{figure}

\subsubsection{工作量函数的建立}
工作量由工作时间决定，即出警时间与办案时间，其中，出警时间是路程/速度，办案时间由所调查资料可知，平均时长为30分钟。

	对于每一个交巡警服务平台：

    设交巡警服务平台集合为 \( P = \{ p_1, p_2, \ldots, p_m \} \)，
    路口节点集合为 \( N = \{ n_1, n_2, \ldots, n_n \} \)。
    

要计算警察完成附近路口任务的总工作量，我们可以定义如下的工作量函数 \( W \)，而\( W_{pi} \)是指第\( i \)个路口的工作量，综合考虑多个因素：

\begin{equation}
   \text{DFS}(v) = 
   \begin{cases} 
   \text{visited}(v) = \text{true}, & \text{if } v \text{ is the starting node} \\
   \text{DFS}(u), & \text{for each neighbor } u \text{ of } v \text{ and } \text{visited}(u) = \text{false}
   \end{cases}
\end{equation}

其中：
\begin{itemize}
    \item \( N \) 是路口数量
    \item \( R_j \) 是第 \( j \) 个路口的发案率
    \item \( T_{\text{case}} \) 是处理每个案件的固定时间，设为 30 分钟（0.5 小时）
    \item \( V \) 是警察行进的速度（单位：公里/小时）
    \item \( D_j \) 是从起点到第 \( j \) 个路口的距离（单位：公里）
\end{itemize}

优化目标是最小化警察完成所有任务的工作量方差 \( \sigma^2 \) ，即：

\[
\min \sigma^2 = \min \left( \frac{1}{m} \sum_{i=1}^{m} \left( W_{pi} - \bar{W} \right)^2 \right)
\]

其中 \( \bar{W} = \frac{1}{m} \sum_{i=1}^{m} W_{pi} \) 是工作量的平均值。

\begin{itemize}
    \item 第一个约束条件表示每个交巡警服务平台只能处理一个路口，即：
    \[
    \sum_{j=1}^{n} x_{ij} = 1, \quad \forall i \in P
    \]
    \item 第二个约束条件表示所有路口必须被处理，即：
    \[
    \sum_{i=1}^{m} x_{ij} = 1, \quad \forall j \in N
    \]
    \item 第三个约束条件表示 \( x_{ij} \) 是决策变量，当平台 \( p_i \) 处理路口 \( n_j \) 时，\( x_{ij} = 1 \)；否则，\( x_{ij} = 0 \)，即：
    \[
    x_{ij} \in \{0, 1\}, \quad \forall i \in P, \forall j \in N
    \]
\end{itemize}



s.t.
\begin{equation}
\begin{cases}
\sum_{j=1}^{n} x_{ij} = 1, & \forall i \in P \quad \text{（每个交巡警服务平台只能处理一个路口）} \\
\sum_{i=1}^{m} x_{ij} = 1, & \forall j \in N \quad \text{（所有路口必须被处理）} \\
x_{ij} \in \{0, 1\}, & \forall i \in P, \forall j \in N \quad \text{（决策变量）}
\end{cases}
\end{equation}

\subsubsection{基于优化函数的扩散算法}
\begin{enumerate}
\item 定位每一个交巡警服务平台，对所有平台，以相同速率进行扩散搜索，直到搜索到第一个路口节点。
\item 搜索到第一个路口节点后，进行工作量函数的计算，根据计算结果，调整该交巡警平台的扩散搜索速率。
\item 继续重复此循环，直到3km内所有路口节点被搜索完毕，程序终止。
\end{enumerate}

优点在于无需去除重叠区域且工作量分配更加均匀。
\begin{enumerate}
    \item \textbf{以相同速率进行扩散搜索，直到搜索到第一个路口节点}：
    
    对每一个交巡警服务平台 \( p_i \in P \)，设初始搜索速率为 \( v_0 \)，
    在时间 \( t \) 内的搜索半径为 \( r_i(t) = v_0 \cdot t \)。
    搜索半径 \( r_i \) 满足：
    \[
    r_i(t) = \min \{ r \mid \exists n_j \in N, \text{dist}(p_i, n_j) \leq r \}
    \]
    
    \item \textbf{每扩张一次距离，进行一次工作量函数的计算，根据计算结果调整该交巡警平台的扩散搜索速率}：
    
    设工作量函数为 \( W(p_i) \)，则新的搜索速率 \( v_i \) 为：
    \[
    v_i = f(W(p_i))
    \]
    其中，函数 \( f \) 根据具体工作量计算结果调整搜索速率。
    
    \item \textbf{继续重复此循环，直到3km内所有路口节点被搜索完毕，程序终止}：
    
    设搜索终止距离为 \( R = 3 \) km，
    程序在满足以下条件时终止：
    \[
    \forall n_j \in N, \text{dist}(p_i, n_j) \leq R \text{ for some } p_i \in P
    \]
\end{enumerate}

\subsubsection{模型结果的评价}
由于方差受平均值影响，不能准确反映数据偏离平均值的程度，故引入变异系数作为工作分配是否平均的评判指标。

\begin{equation}
\sigma^2 = \frac{1}{N} \sum_{i=1}^{N} (x_i - \mu)^2
\end{equation}

\begin{equation}
CV = \frac{\sigma}{\mu}
\end{equation}

\begin{itemize}
    \item 方差 (\(\sigma^2\)) 用于描述数据分布的离散程度，但它受平均值 (\(\mu\)) 的影响较大。
    \item 变异系数 (\(CV\)) 定义为标准差 (\(\sigma\)) 与平均值 (\(\mu\)) 的比值，可以更好地反映数据的相对离散程度，且不受数据量纲的影响。
\end{itemize}

\begin{equation}
CV = \frac{\sigma}{\mu}
\end{equation}

通过这种方法，我们可以更准确地评估数据分布的均匀性，进而调整警察的调度策略。

\subsubsection{模型在原平台情况求解的结果}
\begin{center}
\begin{tabular}{ccccccc}
\toprule
交巡警平台 & 管辖节点\\
\midrule
A1 & 1, 69, 74, 78, 75, 73, 71, 68\\
A2 & 2, 70, 43, 44, 72\\
A3 & 3, 55, 65, 66, 64, 54, 67\\
A4 & 4, 62, 63, 60, 57\\
A5 & 5, 49, 50, 53, 51\\
A6 & 6, 47, 59, 52, 58, 56\\
A7 & 7, 30, 32, 48\\
A8 & 8, 33, 46\\
A9 & 9, 35, 34, 45\\
A10 & 10\\
A11 & 11, 26, 27\\
A12 & 12, 25\\
A13 & 13, 21, 22, 23, 24\\
A14 & 14\\
A15 & 15, 28, 29\\
A16 & 16, 36, 37, 38\\
A17 & 17, 41, 42\\
A18 & 18, 80, 81, 82, 83\\
A19 & 19, 77, 79\\
A20 & 20, 84, 85, 86, 87, 88, 89, 90, 91, 92\\

\bottomrule
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ccccccc}
\toprule
站台号 & 原始工作量 & 新方案工作量 \\
\midrule
A1 & 352.565165 & 263.525661 \\
A2 & 237.864546 & 264.434508 \\
A3 & 179.697283 & 234.691742 \\
A4 & 210.248267 & 183.150163 \\
A5 & 311.188695 & 206.311966 \\
A6 & 75.000000 & 234.426678 \\
A7 & 283.580091 & 231.482092 \\
A8 & 154.549541 & 154.549541 \\
A9 & 258.540947 & 203.962655 \\
A10 & 48.000000 & 48.000000 \\
A11 & 142.789285 & 142.789285 \\
A12 & 125.724334 & 125.724334 \\
A13 & 272.766606 & 223.183326 \\
A14 & 75.000000 & 126.141904 \\
A15 & 63.000000 & 120.498126 \\
A16 & 159.735949 & 159.735949 \\
A17 & 164.137680 & 164.137680 \\
A18 & 189.512156 & 195.590621 \\
A19 & 104.291359 & 165.873061 \\
A20 & 338.864981 & 308.987194 \\

\bottomrule
\end{tabular}
\end{center}

证明了基于工作量函数优化的负反馈扩散算法，在解决平均工作量问题上更有优越性。

结果图如下：

    \begin{figure}[H] % [H] 表示强制当前位置插入图片
        \centering % 使图片居中
        \includegraphics[width=0.6\textwidth]{"./picture/Q3 answer.png"} % 图片文件名及宽度调整
        \caption{问题三结果图} % 图片标题
        \label{fig:example} % 图片标签
    \end{figure}

\newpage
\subsubsection{基于蒙特卡洛的新平台设置方案}
假设我们需要计算某个函数 \( f(x) \) 在区间 \([a, b]\) 上的积分：
\begin{equation}
I = \int_{a}^{b} f(x) \, dx
\end{equation}


在区间 \([a, b]\) 上生成 \( N \) 个随机样本 \( x_1, x_2, \ldots, x_N \)。


对函数 \( f(x) \) 在这些随机样本点上的值取平均：
\begin{equation}
\bar{f} = \frac{1}{N} \sum_{i=1}^{N} f(x_i)
\end{equation}


积分 \( I \) 可以近似为：
\begin{equation}
I \approx (b - a) \cdot \bar{f}
\end{equation}

利用蒙特卡洛算法得出新平台设置方案后，分别计算每种方案的方差，即可知最优新增平台策略。

\begin{center}
\begin{tabular}{ccccccc}
\hline
A21 & A22 & A23 & A24 & $\sigma_W^2$ &\\
\hline
92 & 61 & 27 & 38 & 3573 \\
92 & 61 & 28 & 38 & 3572 \\
92 & 61 & 28 & 39 & 3575 \\
92 & 48 & 28 & 39 & 3821 \\
91 & 61 & 28 & 38 & 4541 \\
87 & 61 & 28 & 38 & 2959 \\
\hline
\end{tabular}
\end{center}

由此，我们新设置的平台为（A21，87），
（A22，61），
（A23，28），
（A24，38）。

添加完平台后，各平台工作量方差减小为2959。\subsubsection{结果的检验}
在满足了3分钟内全覆盖的基础上，且工作量更为平均。
\subsubsection{问题的结论}
由此，我们新设置的平台为（A21，87），
（A22 	61），
（A23 	28），
（A24	38）。

添加完平台后，各平台工作量方差减小为2959。
    \subsection{问题四模型的建立与求解}
\subsubsection{数据预处理}
	首先，我们读取文件，根据区域名称提取出节点坐标、节点间连接关系、平台所在节点和路口所在节点等信息，并将这些数据进行格式化和存入数据库。然后，我们计算连接节点间的欧几里得距离。考虑到点与点之间存在连接关系，并包含距离信息，我们构建了节点网络地图。

    \begin{figure}[H] % [H] 表示强制当前位置插入图片
        \centering % 使图片居中
        \includegraphics[width=0.6\textwidth]{"./picture/Q4_origin.png"} % 图片文件名及宽度调整
        \caption{问题四原平台部署图} % 图片标题
        \label{fig:example} % 图片标签
    \end{figure}

	\subsubsection{评价现有平台设置方式}
工作量由工作时间决定，即出警时间与办案时间，其中，出警时间是路程/速度，出警时间由所调查资料可知，平均时长为30分钟。



\begin{equation}
W_{p} = \sum_{i=1}^{m}\sum_{j=1}^{n} \left( R_j \times T_{\text{case}} + 2 \times \frac{D_j}{V} \right)
\end{equation}

\(W_p\)为全市平台总工作量。



\begin{equation}
\bar{W} = \frac{1}{m}W_{p}
\end{equation}

\(\bar{W}\)为全市平台平均工作量。

{计算工作量的方差 \(\sigma_W^2\)}
\begin{equation}
\sigma_W^2 = \frac{1}{m} \sum_{i=1}^{m} (W_{pi} - \bar{W})^2
\end{equation}

在原平台部署方式下，基于第三问负反馈扩散计算模型所得到的各平台总工作量的方差：10483.69。三分钟内未覆盖的路口节点有98个，故可以看出原平台部署方案还有优化空间。

\subsubsection{模型建立}
根据对原平台部署方案的分析，其部署方案存在同一区域交巡警平台重复部署，偏远地区未部署交巡警平台等问题。分别以该市所有路口节点为中心，计算该节点三公里内的总工作量，得到由各节点总工作量组成的列表，由大到小排序后，通过计算密度函数验证其基本服从卡方分布。基于减小方差的目的每次选取平台位置都选择最靠近平均数的节点，以保证在该次选取的数据集中方差最小。选取平台后，从可选点中扣除平台所在点及其三公里所有可选点，以避免平台管辖区域的冗余。之后在重新计算剩余各点工作量的平均数，重复以上步骤，直到选出八十个平台为止。

\subsubsection{平台部署模型的建立}
{1. 计算每个节点三公里内的总工作量}

对于每个节点 \( n_i \)，计算其三公里内的总工作量 \( W_{n_i} \)：
\begin{equation}
W_{n_i} = \sum_{j \in \{ j \,|\, d(n_i, n_j) \leq 3 \text{ km} \}} \left( R_j \times T_{\text{case}} + 2 \times \frac{D_j}{V} \right)
\end{equation}

{2. 将各节点总工作量列表排序}

对所有节点的总工作量进行排序，得到排序后的列表 \( W_{\text{sorted}} \)：
\begin{equation}
W_{\text{sorted}} = \text{sort}( \{ W_{n_i} \}_{i=1}^n )
\end{equation}

{3. 计算密度函数并验证其分布}
给定数据样本 \( \{x_1, x_2, \ldots, x_n\} \)，核密度估计函数 \( \hat{f}(x) \) 定义为：
\begin{equation}
\hat{f}(x) = \frac{1}{n h} \sum_{i=1}^{n} K\left( \frac{x - x_i}{h} \right)
\end{equation}

其中：
\begin{itemize}
    \item \( n \) 是数据点的数量。
    \item \( h \) 是带宽（平滑参数）。
    \item \( K \) 是核函数，通常使用高斯核函数，高斯核函数定义为：
\end{itemize}

\begin{equation}
K(u) = \frac{1}{\sqrt{2\pi}} \exp\left( -\frac{u^2}{2} \right)
\end{equation}

计算密度函数，并验证其基本服从卡方分布。每次抽取平均值点，以减小方差和变异系数。

    \begin{figure}[H] % [H] 表示强制当前位置插入图片
        \centering % 使图片居中
        \includegraphics[width=0.6\textwidth]{"./picture/K.png"} % 图片文件名及宽度调整
        \caption{K方检验图} % 图片标题
        \label{fig:example} % 图片标签
    \end{figure}

{4. 选择平台位置}

每次选取的平台位置选择最靠近当前工作量平均数的节点，以减小方差。

{计算当前平均数}

\begin{equation}
\bar{W} = \frac{1}{|N|} \sum_{i \in N} W_{n_i}
\end{equation}

{选择最靠近平均数的节点}

\begin{equation}
n_{\text{selected}} = \arg\min_{n_i \in N} |W_{n_i} - \bar{W}|
\end{equation}

{5. 扣除平台所在点及其三公里内所有可选点}

选取平台后，从可选点中扣除平台所在点及其三公里所有可选点：
\begin{equation}
N = N \setminus \{ n_i \,|\, d(n_{\text{selected}}, n_i) \leq 3 \text{ km} \}
\end{equation}

{6. 重新计算剩余各点工作量的平均数，重复步骤}

重复以上步骤，直到选出八十个平台为止。


\subsubsection{模型求解的结果}

以下是新部署方案下的具体平台管辖分配。

\begin{longtable}{cc}
\caption{平台管辖分配表}\\
\toprule
区域 & 节点\\
\midrule
\endfirsthead

\toprule
区域 & 节点\\
\midrule
\endhead

\bottomrule
\endfoot

\midrule
\endlastfoot

A3 & 3, 44, 55, 65, 66, 64, 54, 63 \\
A5 & 5, 49, 50, 53, 47, 48 \\
A11 & 11, 26, 27 \\
A24 & 24, 25, 13 \\
A33 & 33, 32, 34, 8, 9, 7, 31, 35, 46, 36, 45, 37, 16 \\
A40 & 40, 39, 2 \\
A42 & 42, 43, 17, 70, 72, 41 \\
A57 & 57, 60, 58, 56, 59, 52, 51, 4, 62, 6 \\
A75 & 75, 76, 68, 77, 67, 1, 69, 78, 74, 19, 71 \\
A81 & 81, 82, 18, 83, 80, 79, 73 \\
A86 & 86, 20, 85, 84 \\
A92 & 92, 91, 87, 88, 90, 89 \\
B100 & 100, 132, 133, 134, 135, 96, 138 \\
B110 & 110, 109, 112, 94, 111, 108, 107, 106, 113, 105, 114, 104, 115, 95 \\
B123 & 123, 122, 120, 124, 126, 119, 121, 125, 127, 128, 118, 130, 117, 129, 116, 131 \\
B152 & 152, 151, 150, 153, 147, 149, 146, 145, 148, 141, 142, 139, 140, 144, 99 \\
B157 & 157, 158, 155, 162, 159, 154, 156, 160 \\
B165 & 165, 98, 164, 163 \\
C174 & 174, 220, 219, 221, 213, 212, 211, 214 \\
C176 & 176, 188, 187, 184, 185, 186 \\
C193 & 193, 192, 194, 191, 195, 189, 190, 168 \\
C197 & 197, 196, 175, 198 \\
C208 & 208, 209, 207, 199, 210, 206, 205 \\
C225 & 225, 170, 226, 223, 224, 222, 172, 218, 217 \\
C231 & 231, 171, 244, 232, 216, 233, 245, 228, 227 \\
C237 & 237, 236, 235, 173, 234, 30, 247, 238 \\
C241 & 241, 242, 246, 243, 230, 240, 253, 229 \\
C249 & 249, 258, 167, 260, 250, 259, 248 \\
C265 & 265, 262, 166, 261, 263 \\
C268 & 268, 269, 270, 267, 266, 257 \\
C272 & 272, 182, 294, 271, 293, 292, 256 \\
C274 & 274, 275, 273, 276, 278, 179 \\
C282 & 282, 281, 283, 280, 291, 277, 284 \\
C290 & 290, 289, 285, 288, 296, 279, 286, 295, 287, 297 \\
C304 & 304, 314, 299, 303, 305, 300, 302, 315, 298, 301, 316 \\
C307 & 307, 180, 310, 308, 306, 311, 309 \\
C319 & 319, 318, 313, 317, 312, 181 \\
D322 & 322, 361, 367 \\
D327 & 327, 341, 338, 343, 342, 340, 326 \\
D329 & 329, 330, 390, 331 \\
D333 & 333, 336, 334, 339, 335, 328 \\
D345 & 345, 323, 344 \\
D348 & 348, 349, 347, 320, 350, 368 \\
D360 & 360, 357, 353, 359, 346, 356, 358, 352, 354, 321, 355, 351 \\
D363 & 363, 324, 364, 365, 366, 325 \\
E372 & 372, 22, 23, 21, 457, 456 \\
E375 & 375, 429, 424, 430, 425, 428, 431, 426, 432, 433, 374, 427, 434, 435, 436 \\
E377 & 377, 376 \\
E380 & 380, 396, 441, 397 \\
E382 & 382, 101, 403, 93, 102, 103 \\
E393 & 393, 392, 391, 394 \\
E399 & 399, 400, 381, 401, 405, 398, 406 \\
E407 & 407, 404, 438, 408 \\
E413 & 413, 412, 414, 409, 410, 415, 416, 161, 411, 402 \\
E421 & 421, 417 \\
E423 & 423, 379, 422, 378 \\
E437 & 437, 373 \\
E440 & 440, 442, 395, 439, 443 \\
E444 & 444, 447, 386 \\
E445 & 445, 446, 455, 448 \\
E452 & 452, 451, 453, 464, 450, 462, 454, 465 \\
E460 & 460, 383, 461 \\
E469 & 469, 470, 463, 468 \\
E472 & 472, 384, 471, 466, 467 \\
E473 & 473, 385, 474, 449 \\
F478 & 478, 542, 537, 538, 543, 544, 539 \\
F479 & 479, 580, 576, 577, 581, 579, 573 \\
F480 & 480, 567, 568, 562, 566 \\
F486 & 486, 487, 491, 458, 493 \\
F490 & 490, 481, 531, 489 \\
F501 & 501, 497, 477, 530, 498, 496, 500, 492, 495, 499 \\
F503 & 503, 519, 502, 518, 520, 521, 517, 529, 516, 494 \\
F506 & 506, 505, 509, 507, 508, 504 \\
F525 & 525, 514, 527, 524, 528, 526, 523, 515, 513, 522, 512 \\
F535 & 535, 534, 545, 546, 533, 476, 536 \\
F548 & 548, 532, 549, 547, 552, 553 \\
F557 & 557, 475, 564, 556, 555, 554, 563, 565 \\
F559 & 559, 550, 558, 551 \\
F561 & 561, 38 \\
F570 & 570, 569, 571, 484 \\
\bottomrule
\end{longtable}

\subsubsection{结果的检验}

在对原平台部署方案优化后得到新方案的变异系数（即工作量不平均特征）减少11\%，未覆盖节点数量减少44.90\%，故可得到现部署方案比原部署方案更合理。

    \begin{figure}[H] % [H] 表示强制当前位置插入图片
        \centering % 使图片居中
        \includegraphics[width=0.6\textwidth]{"./picture/Q4_middle1.5_80.png"} % 图片文件名及宽度调整
        \caption{问题四优化后平台部署图} % 图片标题
        \label{fig:example} % 图片标签
    \end{figure}

\subsubsection{问题的结论}
在不改变平台数量的情况下，原始部署方案有98个节点未被覆盖（即三分钟内无法到达），而修改后的结果只有54个节点未被覆盖，原变异系数:0.46，现变异系数:0.41，体现了我们算法的优越性。
    \subsection{问题五模型的建立与求解}
\subsubsection{模型建立流程}

先用扩散算法得出小偷的可能的逃跑区域，再调整递归回溯的最远距离，建立最大流模型并用二分查找进行求解，最终得出优化的围堵方案。

\subsubsection{扩散搜索模型的建立}

	定位小偷起始位置，对所有平台，以相同扩散速率进行搜索，若搜索到的节点未被其他平台添加到管辖区域内，则将其加入自己的管辖区。在每一轮增加搜索距离之前，计算各个平台工作量之和，根据计算结果，调整该交巡警平台的扩散搜索速率。重复此循环，直到3km内所有路口节点被搜索完毕，程序终止。

\subsubsection{最大流算法的建立}
{图的构建：}

设图 \( G = (V, E) \) 其中：
\begin{itemize}
    \item \( V \) 为节点集合，包含警察局、路口、源点和汇点。
    \item \( E \) 为边集合，表示警察可以在时间 \( T \) 内到达的路口。
\end{itemize}

{最大流模型：}

\[
\max \sum_{(i, j) \in E} f(i, j)
\]

约束条件：

\[
\begin{aligned}
& \sum_{(i, j) \in E} f(i, j) \leq c(i, j), && \forall (i, j) \in E \\
& \sum_{i} f(s, i) = \sum_{j} f(j, t) = |K|, && \text{流量守恒}
\end{aligned}
\]

二分查找法：

\[
T_{\text{mid}} = \frac{T_{\min} + T_{\max}}{2}
\]
判断在 \( T_{\text{mid}} \) 时间内是否能够封锁所有路口。如果可以，调整 \( T_{\max} = T_{\text{mid}} \)；否则，调整 \( T_{\min} = T_{\text{mid}} \)。

\subsubsection{迭代模型的求解}
先从小偷原初所在位置，对三公里范围内进行扩散搜索后，再调整递归回溯的最远距离，即这个区域要封锁的目标路口节点，对时间进行迭代，每一次找出目标路口节点后，利用最大流二分查找计算围堵所需的最小时间，并与嫌疑人最快逃跑时间进行比较，若小于嫌疑人最快逃跑时间，则围堵成功。
\subsubsection{模型求解的结果}
最优时间: 10.876min。

\begin{center}
    \setlength{\tabcolsep}{2mm}{
        \begin{tabular}{cccccc}
            \specialrule{1.2pt}{0pt}{0pt} % 设置顶部粗线
            \textbf{节点} & \textbf{平台} & \textbf{节点} & \textbf{平台} & \textbf{节点} & \textbf{平台} \\
            \midrule  % 设置中间横线
            2 & 84 & 175 & 212 & 477 & 535 \\
            3 & 85 & 177 & 175 & 478 & 568 \\
            5 & 193 & 178 & 213 & 480 & 555 \\
            12 & 24 & 179 & 221 & 481 & 554 \\
            16 & 553 & 180 & 178 & 482 & 565 \\
            17 & 90 & 181 & 274 & 483 & 528 \\
            19 & 92 & 182 & 182 & 484 & 521 \\
            167 & 252 & 320 & 370 & 485 & 563 \\
            168 & 186 & 323 & 248 & 378 & 530 \\
            169 & 254 & 326 & 371 & 383 & 459 \\
            172 & 277 & 372 & 491 & 384 & 12 \\
            174 & 275 & 375 & 487 & 475 & 567 \\
            175 & 212 & 376 & 22 & 476 & 476 \\
    
            \specialrule{1.2pt}{0pt}{0pt} % 设置底部粗线
        \end{tabular}
    }
\end{center}

嫌疑人最快逃跑时间:10.7min。

需要封锁的节点：{'212', '491', '521', '24', '371', '554', '370', '175', '544', '459', '221', '530', '563', '84', '186', '555', '85', '471', '535', '92', '248', '567', '90', '213', '182', '22', '178', '274', '487', '193', '275', '277', '254', '568', '565', '252', '528'}。
\subsubsection{结果的检验与仿真}
确定了最佳抓捕方案后，对嫌疑人逃跑进行仿真，进行10次仿真后发现嫌疑人以60千米每小时的速度进行逃跑也无法逃脱。
\subsubsection{模型的稳定性}
通过改变嫌疑人逃跑速度，分别测试了时速为60千米与70千米直至120千米时，时速120km时甚至可以在六分钟完成围堵，都可以完成抓捕，证明了模型的稳定性。
\subsubsection{问题结论}
扩散算法得出小偷的可能的逃跑区域，再调整递归回溯的最远距离，建立最大流模型并用二分查找进行求解，最终得出优化的围堵方案。

结果如下，

\begin{center}
    \setlength{\tabcolsep}{9mm}{
        \begin{tabular}{cc}
            \specialrule{1.2pt}{0pt}{0pt} % 设置顶部粗线
            \textbf{节点} & \textbf{平台}\\
            \midrule  % 设置中间横线
            2 & 84\\
            3 & 85\\
            5 & 193\\
            12 & 24\\
            16 & 553\\
            17 & 90\\
            19 & 92\\
            167 & 252\\
            168 & 186\\
            169 & 254\\
            172 & 277\\
            174 & 275\\
            175 & 212\\
            177 & 175\\
            178 & 213\\
            179 & 221\\
            180 & 178\\
            181 & 274\\
            182 & 182\\
            320 & 370\\
            323 & 248\\
            326 & 371\\
            372 & 491\\
            375 & 487\\
            376 & 22\\
            378 & 530\\
            383 & 459\\
            384 & 12\\
            475 & 567\\
            476 & 476\\
            477 & 535\\
            478 & 568\\
            480 & 555\\
            481 & 554\\
            482 & 565\\
            483 & 528\\
            484 & 521\\
            485 & 563\\
            \specialrule{1.2pt}{0pt}{0pt} % 设置底部粗线
        \end{tabular}
    }
\end{center}

只调用了38个交巡警服务平台，最优时间: 10.876min。


\section{模型评价与改进}
\subsection{模型优点}
\begin{enumerate}[(1)]
    \item \textbf{针对第一问中}，该模型能够高效地分配警力，确保每个交巡警服务平台合理地处理附近的路口任务。
    \item \textbf{工作量方差最小化}的优化目标使得各交巡警服务平台的工作负担更加均衡，避免了个别平台工作过于繁重的问题。
    \item \textbf{综合考虑多因素}，如路程、速度和处理案件的固定时间，模型更具实际操作性和现实意义。
    \item \textbf{决策变量的引入}，使得模型更加灵活，可以根据实际情况进行调整，确保所有路口都被处理。
\end{enumerate}

\subsection{模型缺点}
\begin{enumerate}[(1)]
    \item \textbf{未考虑交通状况}，模型假设警察行进速度恒定，未考虑交通拥堵等实际情况，这可能影响出警时间的准确性。
    \item \textbf{缺乏动态调整机制}，模型基于静态数据，未考虑实时调整的可能性，无法应对突发事件和动态变化的情况。
    \item \textbf{忽略了其他因素}，如天气、路况等外部因素对出警时间的影响，可能导致实际操作中的偏差。
    \item \textbf{工作量计算的简单性}，工作量的计算仅考虑了路程和处理时间，未考虑案件复杂度等其他影响因素，可能导致工作量估计不准确。
\end{enumerate}



    \begin{thebibliography}{9} % 参考文献
		%\bibitem{bib:8}何晓群.多元统计分析.北京：中国人民大学出版社，2012.
		%\bibitem{bib:9}徐维超. 相关系数研究综述[J]. 广东工业大学学报,2012,29(3):12-17.
    \end{thebibliography}

我们翻阅了相关文献，发现了没有队伍与我们的主要模型与算法重合，保证了论文的创新性。

    \newpage
    \section{附录}
    %插入代码内容
\begin{lstlisting}
import matplotlib.pyplot as plt
import random
import matplotlib.patheffects as path_effects
import matplotlib.cm as cm
import numpy as np
import matplotlib.colors as mcolors
import heapq
from scipy.optimize import linear_sum_assignment
from scipy.spatial.distance import squareform
from scipy.cluster.hierarchy import linkage, fcluster


def read_f_file(file_name):
    def line_count(data):
        line = 0
        while True:
            temp = data.readline()
            if temp == '':
                data.seek(0, 0)
                return line
            line += 1
    file = open(file_name, 'r', encoding='utf8')
    line = line_count(file)
    f = []
    for i in range(line):
        f.append(file.readline().strip('\n').split('\t'))
    return f


def main():
    f_point = read_f_file('data1.txt')
    f_relation = read_f_file('data2.txt')
    f_plant = read_f_file('data3.txt')
    f_inout_point = read_f_file('data4.txt')
    a_area_inout_point = [i[2] for i in f_inout_point]
    city_inout_point = [i[1] for i in f_inout_point]
    del a_area_inout_point[0]
    del city_inout_point[0]
    plant_name = [i[0] for i in f_plant]
    plant_point = [i[1] for i in f_plant]
    del plant_name[0]
    del plant_point[0]
    inout_point = a_area_inout_point + city_inout_point
    def distance(x1, y1, x2, y2):
        return ((x1-x2)**2 + (y1-y2)**2)**0.5

    def get_one_area_point(area_name=''):
        # points_list[[class_name,x,y],[class_name,x,y],......,[class_name,x,y]]
        points_dict = {}
        if area_name == '':
            for j in range(1, len(f_point)):
                points_dict[f_point[j][0]] = [float(f_point[j][1]), float(f_point[j][2]), f_point[j][3], 0]
                if f_point[j][0] in plant_point:
                    points_dict[f_point[j][0]].append(plant_name[plant_point.index(f_point[j][0])])
                else:
                    points_dict[f_point[j][0]].append('nor')
                if f_point[j][0] in inout_point:
                    points_dict[f_point[j][0]][3] = 1
                points_dict[f_point[j][0]].append(f_point[j][4])
        for j in range(1, len(f_point)):
            if f_point[j][3] == area_name:
                points_dict[f_point[j][0]] = [float(f_point[j][1]), float(f_point[j][2]), f_point[j][3], 0]
                if f_point[j][0] in plant_point:
                    points_dict[f_point[j][0]].append(plant_name[plant_point.index(f_point[j][0])])
                else:
                    points_dict[f_point[j][0]].append('nor')
                if f_point[j][0] in inout_point:
                    points_dict[f_point[j][0]][3] = 1
                points_dict[f_point[j][0]].append(f_point[j][4])
        return points_dict

    def create_road_point_relation(points_dict):
        # points_relation = {point_name1:[[distance11,point_name11],[distance11,point_name12],...],
        # point_name2:[[distance21,point_name11],[distance22,point_name12],...]...}
        points_relation = {}
        for i in range(1,len(f_relation)):
            try:
                points_dict.get(f_relation[i][1])
                points_dict.get(f_relation[i][0])
                try:
                    points_relation.get(f_relation[i][0])
                    temp_d = distance(points_dict[f_relation[i][0]][0], points_dict[f_relation[i][0]][1],
                                      points_dict[f_relation[i][1]][0], points_dict[f_relation[i][1]][1])
                    points_relation[f_relation[i][0]].append([temp_d, f_relation[i][1]])
                except:
                    temp_d = distance(points_dict[f_relation[i][0]][0], points_dict[f_relation[i][0]][1],
                                      points_dict[f_relation[i][1]][0], points_dict[f_relation[i][1]][1])
                    points_relation[f_relation[i][0]] = [[temp_d, f_relation[i][1]]]
            except:
                pass
        for i in range(1,len(f_relation)):
            try:
                points_dict.get(f_relation[i][1])
                points_dict.get(f_relation[i][0])
                try:
                    points_relation.get(f_relation[i][1])
                    temp_d = distance(points_dict[f_relation[i][0]][0], points_dict[f_relation[i][0]][1],
                                      points_dict[f_relation[i][1]][0], points_dict[f_relation[i][1]][1])
                    points_relation[f_relation[i][1]].append([temp_d, f_relation[i][0]])
                except:
                    temp_d = distance(points_dict[f_relation[i][0]][0], points_dict[f_relation[i][0]][1],
                                      points_dict[f_relation[i][1]][0], points_dict[f_relation[i][1]][1])
                    points_relation[f_relation[i][1]] = [[temp_d, f_relation[i][0]]]
            except:
                pass
        return points_relation

    def dijkstra(area, start, end):
        # 初始化最小堆
        graph = create_road_point_relation(get_one_area_point(area))
        queue = [(0, start, [])]
        seen = set()
        min_dist = {start: 0}
        while queue:
            (cost, v1, path) = heapq.heappop(queue)
            if v1 in seen:
                continue
            path = path + [v1]
            seen.add(v1)

            if v1 == end:
                return (cost, path)
            for c, v2 in graph.get(v1, []):
                if v2 in seen:
                    continue
                prev = min_dist.get(v2, None)
                next = cost + c
                if prev is None or next < prev:
                    min_dist[v2] = next
                    heapq.heappush(queue, (next, v2, path))
        return (float("inf"), [])

    def calculate_work(hold_area, area=''):
        nodes = get_one_area_point(area)
        w = {}
        for key, value in hold_area.items():
            t = 0
            for i in range(len(value)):
                for j, k in nodes.items():
                    if key in k:
                        pp = j
                        break
                dis, link = dijkstra(area, pp, value[i])
                t += float(nodes[value[i]][5]) * (dis * 0.2 + 30)
            w[key] = t
        return w

    def search(area=''):
        nodes = get_one_area_point(area)
        connections = create_road_point_relation(nodes)
        plant_reach_area = dict()
        max_reach = 30
        def track_back_search_area(point, dis, visited):
            for j in connections.get(point, []):
                new_dis = dis + j[0]
                if j[1] not in visited and new_dis < max_reach:
                    visited.add(j[1])
                    plant_reach.add(j[1])
                    track_back_search_area(j[1], new_dis, visited)
                    visited.remove(j[1])  # 回溯时移除节点
        for i in range(len(plant_point)):
            if connections.get(plant_point[i]) != None:
                plant_reach = set([plant_point[i]])
                dis = 0
                track_back_search_area(plant_point[i], dis, set([plant_point[i]]))
                plant_reach_area[plant_name[i]] = plant_reach
        return plant_reach_area

    def search_by_step(area):
        nodes = get_one_area_point(area)
        connections = create_road_point_relation(nodes)
        plant_hold = {}
        all_point = []
        for key, value in nodes.items():
            if value[4] != 'nor':
                plant_hold[value[4]] = []
            all_point.append(key)
        all_point = set(all_point)
        rate = [1 for i in range(len(plant_hold))]
        max_reach = [(1 / 2) * rate[j] ** 2 for j in range(len(plant_hold))]
        for i in range(5, 240):
            plant_reach_area = dict()
            max_reach = [(1/2) * rate[j] ** 2 + max_reach[j] for j in range(len(plant_hold))]
            def track_back_search_area(point, dis, visited):
                for k in connections.get(point, []):
                    new_dis = dis + k[0]
                    if k[1] not in visited and new_dis < max_reach[j]:
                        visited.add(k[1])
                        plant_reach.add(k[1])
                        track_back_search_area(k[1], new_dis, visited)
                        visited.remove(k[1])  # 回溯时移除节点
            for j in range(len(plant_point)):
                if connections.get(plant_point[j]) != None:
                    plant_reach = set([plant_point[j]])
                    dis = 0
                    if max_reach[j] < 35:
                        track_back_search_area(plant_point[j], dis, set([plant_point[j]]))
                        plant_reach_area[plant_name[j]] = plant_reach
            for key,value in plant_reach_area.items():
                for p in value:
                    if p in all_point:
                        all_point -= {p}
                        plant_hold[key].append(p)
            c_t = calculate_work(plant_hold, area)
            av = [value for k, value in c_t.items()]
            rate = [(sum(av)/len(c_t))/value for k, value in c_t.items()]
        print(all_point)
        print(len(all_point))
        print(plant_hold)
        print(calculate_work(plant_hold))
        return plant_hold


    def draw_map(area=''):
        color_map = {'A': 'red', 'B': 'blue', 'C': 'green', 'D': 'yellow', 'E': 'purple'}  # 可以根据需要添加更多类别和颜色
        fig, ax = plt.subplots(figsize=(50, 50), dpi=300)
        nodes = get_one_area_point(area)
        # 绘制节点
        for node, (x, y, category, entrance, description, p) in nodes.items():
            color = color_map.get(category, 'black')  # 如果类别不在映射中，默认为黑色
            ax.plot(x, y, 'o', color=color)
            ax.text(x, y, node, fontsize=12, ha='right')
            #label = f'*{description}' if entrance == 1 else description
            #ax.text(x, y, label, fontsize=10, ha='right')
        connections = create_road_point_relation(nodes)
        # 绘制连接关系
        for node, edges in connections.items():
            x1, y1, _, _, _, _ = nodes[node]
            for edge in edges:
                distance, target = edge
                if target in nodes:
                    x2, y2, _, _, _, _ = nodes[target]
                    ax.plot([x1, x2], [y1, y2], 'k-', lw=0.5)  # 节点之间的线
                    mid_x = (x1 + x2) / 2
                    mid_y = (y1 + y2) / 2
                    # 在线的中点处标注距离
                    ax.text(mid_x, mid_y, f'{distance / 10:.1f}', fontsize=8, ha='center', va='center', color='blue')
        collections = search_by_step(area)
        all_point_relate_plant = {}
        collection_colors = colors = [
            "#FF0000",  # 红色
            "#00FF00",  # 绿色
            "#0000FF",  # 蓝色
            "#FFFF00",  # 黄色
            "#FF00FF",  # 品红
            "#00FFFF",  # 青色
            "#FFA500",  # 橙色
            "#800080",  # 紫色
            "#00FF7F",  # 春绿
            "#FF1493",  # 深粉红
            "#1E90FF",  # 道奇蓝
            "#32CD32",  # 石灰绿
            "#FF4500",  # 橙红
            "#8A2BE2",  # 蓝紫色
            "#ADFF2F",  # 绿黄色
            "#FF69B4",  # 热粉红
            "#40E0D0",  # 绿松石
            "#FF6347",  # 番茄
            "#EE82EE",  # 紫罗兰
            "#7FFF00",   # 查特酒绿
            "#FF0000",  # 红色
            "#00FF00",  # 绿色
            "#0000FF",  # 蓝色
            "#FF0000",  # 红色
            "#00FF00",  # 绿色
            "#0000FF",  # 蓝色
            "#FFFF00",  # 黄色
            "#FF00FF",  # 品红
            "#00FFFF",  # 青色
            "#FFA500",  # 橙色
            "#800080",  # 紫色
            "#00FF7F",  # 春绿
            "#FF1493",  # 深粉红
            "#1E90FF",  # 道奇蓝
            "#32CD32",  # 石灰绿
            "#FF4500",  # 橙红
            "#8A2BE2",  # 蓝紫色
            "#ADFF2F",  # 绿黄色
            "#FF69B4",  # 热粉红
            "#40E0D0",  # 绿松石
            "#FF6347",  # 番茄
            "#EE82EE",  # 紫罗兰
            "#7FFF00",  # 查特酒绿
            "#FF0000",  # 红色
            "#00FF00",  # 绿色
            "#0000FF",  # 蓝色
        ]
        for key, value in collections.items():
            for i in value:
                try:
                    all_point_relate_plant[i].append(key)
                except:
                    all_point_relate_plant[i] = [key]
        for point_name, collection_plants in all_point_relate_plant.items():
            x, y, _, _, class_n, _ = nodes[point_name]
            if class_n != 'nor':
                ax.text(x, y, class_n, fontsize=12, ha='left', va='center',
                            color=collection_colors[(int(class_n[1:]) - 1)%20])
            for i in range(len(collection_plants)):
                ax.scatter(x, y, s=(i + 1) * 100, edgecolor=collection_colors[(int(collection_plants[i][1:]) - 1)%20],
                               facecolor='none', linewidth=0.5)
        # 设置图形范围
        x_values, y_values, _, _, _, _ = zip(*nodes.values())
        ax.set_xlim(min(x_values) - 10, max(x_values) + 10)
        ax.set_ylim(min(y_values) - 10, max(y_values) + 10)
        # 添加标签和标题
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_title('Map')
        ax.legend()
        # 保存图形
        plt.savefig('map.png')

    #print(search_by_step('A'))
    #draw_map('')

    def found_closed_dis(area):
        node = get_one_area_point(area)
        ptp = {}
        for key, value in node.items():
            if value[3] == 1:
                ptp[key] = []
                for i in range(20):
                    t = dijkstra(area, key, str(i+1))
                    ptp[key].append(['A'+str(i+1),t[0]])
        return ptp

    def find_min_sum_distance(graph):
        # 提取点的名称和距离
        points = list(graph.keys())
        all_connections = []
        for point in points:
            all_connections.extend([conn[0] for conn in graph[point]])
        all_connections = list(set(all_connections))
        # 构建成本矩阵
        cost_matrix = np.zeros((len(points), len(all_connections)))
        for i, point in enumerate(points):
            for j, conn in enumerate(all_connections):
                for connection in graph[point]:
                    if connection[0] == conn:
                        cost_matrix[i][j] = connection[1]
                        break
                else:
                    cost_matrix[i][j] = np.inf  # 如果没有连接，设置为无穷大
        # 使用匈牙利算法求解最小成本匹配
        row_ind, col_ind = linear_sum_assignment(cost_matrix)
        # 计算最小距离和
        min_distance_sum = cost_matrix[row_ind, col_ind].sum()
        # 获取匹配结果
        matching = [(points[i], all_connections[j]) for i, j in zip(row_ind, col_ind)]
        return min_distance_sum, matching
    '''
    min_distance_sum, matching = find_min_sum_distance(found_closed_dis('A'))
    print(f"最小距离和是: {min_distance_sum}")
    print("匹配结果是:")
    for match in matching:
        print(match)
    '''

    def release_plant(area=''):
        nodes = get_one_area_point(area)
        connections = create_road_point_relation(nodes)
        point_reach_area = dict()
        max_reach = 30
        def track_back_search_area(point, dis, visited):
            for j in connections.get(point, []):
                new_dis = dis + j[0]
                if j[1] not in visited and new_dis < max_reach:
                    visited.add(j[1])
                    plant_reach.add(j[1])
                    track_back_search_area(j[1], new_dis, visited)
                    visited.remove(j[1])  # 回溯时移除节点
        for key,value in nodes.items():
            plant_reach = set([key])
            dis = 0
            track_back_search_area(key, dis, set(key))
            point_reach_area[key] = list(plant_reach)
        work = calculate_work(point_reach_area, '')
        plant = []
        for i in range(len(work)):
            print(work.values())
            if len(work) != 0 and len(plant) < 80:
                #max_key = max(work, key=work.get)
                average_value = (sum(work.values()) / len(work))*2
                # 找到离平均值最近的value对应的key
                closest_key = min(work, key=lambda k: abs(work[k] - average_value))
                plant.append(closest_key)
                for j in point_reach_area[closest_key]:
                    if j in work.keys():
                        del work[j]
            else:
                break
        return plant
    #print(release_plant(''))

    def found_crime(area):
        nodes = get_one_area_point(area)
        connections = create_road_point_relation(nodes)
        plant_reach_area = dict()
        def track_back_search_area(point, dis, visited):
            for j in connections.get(point, []):
                new_dis = dis + j[0]
                if j[1] not in visited and new_dis < 30:
                    visited.add(j[1])
                    plant_reach.add(j[1])
                    track_back_search_area(j[1], new_dis, visited)
                    visited.remove(j[1])  # 回溯时移除节点
        for i in range(30,32):
            plant_reach = set(['32'])
            dis = 0
            track_back_search_area('32', dis, set(['32']))
            plant_reach_area['32'] = plant_reach
            print(plant_reach_area)
            all_connected_points = plant_reach_area['32']
            round_p = set(all_connected_points)
            for j in list(all_connected_points):
                for k in connections.get(j, []):
                    round_p.add(k[1])
            print(round_p)
            round_p -= all_connected_points
            print(round_p)
        return

main()
\end{lstlisting}
\end{document}       